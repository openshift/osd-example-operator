apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: osd-example-operator-deployment
  namespace: argo
  labels:
    app: osd-example-operator
    version: v1.0.0
    team: sre
spec:
  entrypoint: deploy-pipeline
  arguments:
    parameters:
    - name: app-name
      value: "osd-example-operator"
    - name: app-version
      value: "latest"
    - name: image-registry
      value: "quay.io/app-sre"
    - name: image-name
      value: "osd-example-operator"
    - name: image-tag
      value: "latest"
    - name: int-replicas
      value: "1"
    - name: stage-replicas
      value: "2"
    - name: prod-replicas
      value: "3"
    - name: slack-webhook
      value: ""
    - name: notification-webhook
      value: ""
    - name: approver-email
      value: "sre-team@redhat.com"
    - name: osde2e-image
      value: "quay.io/rh_ee_yiqzhang/osde2e"
    - name: osde2e-tag
      value: "latest"
    - name: enable-notifications
      value: "false"
    - name: enable-approval
      value: "true"


  # Global failure handling
  onExit: notify-on-exit

  templates:
  # Main deployment pipeline
  - name: deploy-pipeline
    steps:
    # Step 1: Send start notification (if enabled)
    - - name: notify-start
        template: send-notification
        arguments:
          parameters:
          - name: message
            value: "🚀 Starting deployment pipeline for {{workflow.parameters.app-name}} v{{workflow.parameters.app-version}}"
          - name: status
            value: "started"
          - name: color
            value: "good"
        when: "{{workflow.parameters.enable-notifications}} == 'true'"

    # Step 2: Deploy to INT environment
    - - name: deploy-to-int
        template: deploy-app
        arguments:
          parameters:
          - name: environment
            value: "int"
          - name: app-name
            value: "{{workflow.parameters.app-name}}"
          - name: app-version
            value: "{{workflow.parameters.app-version}}"
          - name: image-url
            value: "{{workflow.parameters.image-registry}}/{{workflow.parameters.image-name}}:{{workflow.parameters.image-tag}}"
          - name: replicas
            value: "{{workflow.parameters.int-replicas}}"

    # Step 3: Run E2E tests in INT
    - - name: run-e2e-tests
        template: execute-e2e-tests
        arguments:
          parameters:
          - name: environment
            value: "int"
          - name: app-name
            value: "{{workflow.parameters.app-name}}"
          - name: app-version
            value: "{{workflow.parameters.app-version}}"
          - name: image-url
            value: "{{workflow.parameters.image-registry}}/{{workflow.parameters.image-name}}:{{workflow.parameters.image-tag}}"

    # Step 4: Notify E2E success (if notifications enabled)
    - - name: notify-e2e-success
        template: send-notification
        arguments:
          parameters:
          - name: message
            value: "✅ E2E tests passed for {{workflow.parameters.app-name}} v{{workflow.parameters.app-version}} in INT"
          - name: status
            value: "e2e-passed"
          - name: color
            value: "good"
        when: "{{workflow.parameters.enable-notifications}} == 'true'"

    # Step 5: Manual approval gate (if approval enabled)
    - - name: approval-gate
        template: manual-approval
        arguments:
          parameters:
          - name: approval-message
            value: "E2E tests passed for {{workflow.parameters.app-name}} v{{workflow.parameters.app-version}}. Approve deployment to STAGE?"
          - name: approver
            value: "{{workflow.parameters.approver-email}}"
        when: "{{workflow.parameters.enable-approval}} == 'true'"

    # Step 7: Deploy to STAGE environment
    - - name: deploy-to-stage
        template: deploy-app
        arguments:
          parameters:
          - name: environment
            value: "stage"
          - name: app-name
            value: "{{workflow.parameters.app-name}}"
          - name: app-version
            value: "{{workflow.parameters.app-version}}"
          - name: image-url
            value: "{{workflow.parameters.image-registry}}/{{workflow.parameters.image-name}}:{{workflow.parameters.image-tag}}"
          - name: replicas
            value: "{{workflow.parameters.stage-replicas}}"

    # Step 8: Validate STAGE deployment
    - - name: validate-stage
        template: validate-deployment
        arguments:
          parameters:
          - name: environment
            value: "stage"
          - name: app-name
            value: "{{workflow.parameters.app-name}}"
        when: "{{workflow.parameters.enable-approval}} == 'true'"

    # Step 6: Final success notification (if enabled)
    - - name: notify-success
        template: send-notification
        arguments:
          parameters:
          - name: message
            value: "🎉 Successfully deployed {{workflow.parameters.app-name}} v{{workflow.parameters.app-version}} to INT and STAGE!"
          - name: status
            value: "completed"
          - name: color
            value: "good"
        when: "{{workflow.parameters.enable-notifications}} == 'true'"

  # Application deployment template
  - name: deploy-app
    inputs:
      parameters:
      - name: environment
      - name: app-name
      - name: app-version
      - name: image-url
      - name: replicas
    script:
      image: quay.io/openshift/origin-cli:latest
      command: [bash]
      env:
      - name: KUBECONFIG
        value: /tmp/kubeconfig/kubeconfig
      - name: ENVIRONMENT
        value: "{{inputs.parameters.environment}}"
      resources:
        limits:
          cpu: 500m
          memory: 512Mi
        requests:
          cpu: 100m
          memory: 256Mi
      volumeMounts:
      - name: kubeconfig
        mountPath: /tmp/kubeconfig
        readOnly: true
      securityContext:
        runAsNonRoot: true
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: false
        capabilities:
          drop:
          - ALL
      source: |
        set -euo pipefail
        echo "=== Deploying {{inputs.parameters.app-name}} to {{inputs.parameters.environment}} ==="
        echo "Version: {{inputs.parameters.app-version}}"
        echo "Replicas: {{inputs.parameters.replicas}}"

        # Verify kubeconfig is mounted
        if [ ! -f "${KUBECONFIG}" ]; then
          echo "❌ Kubeconfig not found at ${KUBECONFIG}"
          exit 1
        fi

        echo "📋 Testing cluster connectivity..."
        oc version --client

        if ! oc cluster-info &>/dev/null; then
          echo "❌ Cannot connect to cluster"
          exit 1
        fi

        echo "✅ Connected to cluster successfully"

        NAMESPACE="{{inputs.parameters.app-name}}-{{inputs.parameters.environment}}"
        echo "🏗️  Target namespace: ${NAMESPACE}"

        # Create namespace
        cat <<EOF | oc apply -f -
        apiVersion: v1
        kind: Namespace
        metadata:
          name: ${NAMESPACE}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
            version: {{inputs.parameters.app-version}}
            managed-by: argo
        EOF

        # Set environment-specific log level
        if [ "{{inputs.parameters.environment}}" = "prod" ]; then
          LOG_LEVEL="WARN"
        else
          LOG_LEVEL="INFO"
        fi

        # Create ConfigMap
        cat <<EOF | oc apply -f -
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: {{inputs.parameters.app-name}}-config
          namespace: ${NAMESPACE}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
            version: {{inputs.parameters.app-version}}
        data:
          app.properties: |
            app.name={{inputs.parameters.app-name}}
            app.version={{inputs.parameters.app-version}}
            app.environment={{inputs.parameters.environment}}
            app.replicas={{inputs.parameters.replicas}}
            deployment.timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          logging.conf: |
            level=${LOG_LEVEL}
            format=json
        EOF

        # Create ServiceAccount
        cat <<EOF | oc apply -f -
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: {{inputs.parameters.app-name}}
          namespace: ${NAMESPACE}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
        EOF

        # Create ClusterRole
        cat <<EOF | oc apply -f -
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRole
        metadata:
          name: {{inputs.parameters.app-name}}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
        rules:
        - apiGroups: ["managed.openshift.io"]
          resources: ["examples"]
          verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
        - apiGroups: [""]
          resources: ["events"]
          verbs: ["create", "patch"]
        - apiGroups: [""]
          resources: ["configmaps", "secrets"]
          verbs: ["get", "list", "watch"]
        EOF

        # Create ClusterRoleBinding
        cat <<EOF | oc apply -f -
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRoleBinding
        metadata:
          name: {{inputs.parameters.app-name}}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: {{inputs.parameters.app-name}}
        subjects:
        - kind: ServiceAccount
          name: {{inputs.parameters.app-name}}
          namespace: ${NAMESPACE}
        EOF

        # Create Service
        cat <<EOF | oc apply -f -
        apiVersion: v1
        kind: Service
        metadata:
          name: {{inputs.parameters.app-name}}
          namespace: ${NAMESPACE}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
        spec:
          selector:
            app: {{inputs.parameters.app-name}}
          ports:
          - name: http
            port: 8080
            targetPort: 8080
          - name: webhook
            port: 8443
            targetPort: 8443
          type: ClusterIP
        EOF

        # Deploy application
        cat <<EOF | oc apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: {{inputs.parameters.app-name}}
          namespace: ${NAMESPACE}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
            version: {{inputs.parameters.app-version}}
        spec:
          replicas: {{inputs.parameters.replicas}}
          strategy:
            type: RollingUpdate
            rollingUpdate:
              maxUnavailable: 0
              maxSurge: 1
          selector:
            matchLabels:
              app: {{inputs.parameters.app-name}}
          template:
            metadata:
              labels:
                app: {{inputs.parameters.app-name}}
                environment: {{inputs.parameters.environment}}
                version: {{inputs.parameters.app-version}}
            spec:
              containers:
              - name: {{inputs.parameters.app-name}}
                image: {{inputs.parameters.image-url}}
                ports:
                - containerPort: 8080
                  name: http
                - containerPort: 8443
                  name: webhook
                env:
                - name: WATCH_NAMESPACE
                  value: ""
                - name: POD_NAME
                  valueFrom:
                    fieldRef:
                      fieldPath: metadata.name
                - name: OPERATOR_NAME
                  value: {{inputs.parameters.app-name}}
                livenessProbe:
                  httpGet:
                    path: /healthz
                    port: 8081
                  initialDelaySeconds: 15
                  periodSeconds: 20
                readinessProbe:
                  httpGet:
                    path: /readyz
                    port: 8081
                  initialDelaySeconds: 5
                  periodSeconds: 10
                resources:
                  requests:
                    cpu: 100m
                    memory: 128Mi
                  limits:
                    cpu: 500m
                    memory: 512Mi
                securityContext:
                  runAsNonRoot: true
                  allowPrivilegeEscalation: false
                  readOnlyRootFilesystem: true
                  capabilities:
                    drop:
                    - ALL
                volumeMounts:
                - name: tmp
                  mountPath: /tmp
              serviceAccountName: {{inputs.parameters.app-name}}
              securityContext:
                runAsNonRoot: true
                seccompProfile:
                  type: RuntimeDefault
              volumes:
              - name: tmp
                emptyDir: {}
              - name: config
                configMap:
                  name: {{inputs.parameters.app-name}}-config
        EOF

        echo "⏳ Waiting for deployment to be ready..."
        if ! oc wait --for=condition=Available --timeout=300s deployment/{{inputs.parameters.app-name}} -n "${NAMESPACE}"; then
          echo "❌ Deployment failed"
          oc get events -n "${NAMESPACE}" --sort-by='.lastTimestamp'
          exit 1
        fi

        echo "✅ Deployment to {{inputs.parameters.environment}} completed!"

    volumes:
    - name: kubeconfig
      secret:
        secretName: kubeconfig-{{inputs.parameters.environment}}
        defaultMode: 0400

  # E2E test execution using osde2e
  - name: execute-e2e-tests
    inputs:
      parameters:
      - name: environment
      - name: app-name
      - name: app-version
      - name: image-url
    container:
      image: "{{workflow.parameters.osde2e-image}}:{{workflow.parameters.osde2e-tag}}"
      command: ["/bin/bash", "-c"]
      args:
      - |
        set -euo pipefail
        echo "=== Running OSDE2E Tests in {{inputs.parameters.environment}} ==="

        # Set up environment variables for osde2e
        export KUBECONFIG=/tmp/kubeconfig/kubeconfig
        export OPERATOR_IMAGE={{inputs.parameters.image-url}}
        export OPERATOR_NAMESPACE="{{inputs.parameters.app-name}}-{{inputs.parameters.environment}}"
        export TEST_HARNESS="operator"
        export TEST_TIMEOUT="3600"
        export POLLING_TIMEOUT="600"

        # Verify kubeconfig is mounted
        if [ ! -f "${KUBECONFIG}" ]; then
          echo "❌ Kubeconfig not found at ${KUBECONFIG}"
          exit 1
        fi

        # Load osde2e configuration
        CONFIG_FILE="/tmp/osde2e-config/{{inputs.parameters.environment}}-config.yaml"
        if [ -f "${CONFIG_FILE}" ]; then
          echo "📋 Loading osde2e configuration from ${CONFIG_FILE}"
          export OSDE2E_CONFIG="${CONFIG_FILE}"
        else
          echo "⚠️ No specific config found for {{inputs.parameters.environment}}, using defaults"
        fi

        # Run osde2e tests
        echo "🧪 Starting osde2e test execution..."

        # Create osde2e test configuration
        cat > /tmp/test-config.yaml << EOF
        cluster:
          kubeconfig: ${KUBECONFIG}

        tests:
          testTimeout: ${TEST_TIMEOUT}
          pollingTimeout: ${POLLING_TIMEOUT}
          parallelism: 2

        operator:
          name: "{{inputs.parameters.app-name}}"
          namespace: "${OPERATOR_NAMESPACE}"
          image: "${OPERATOR_IMAGE}"

        testHarnesses:
          - "${OPERATOR_IMAGE}"

        environment:
          type: "{{inputs.parameters.environment}}"
        EOF

        # Execute osde2e tests
        echo "🚀 Running osde2e with configuration:"
        cat /tmp/test-config.yaml

        # Run the actual osde2e test command
        if command -v osde2e >/dev/null 2>&1; then
          osde2e test \
            --config-path /tmp/test-config.yaml \
            --test-harness operator \
            --operator-namespace "${OPERATOR_NAMESPACE}" \
            --operator-image "${OPERATOR_IMAGE}" \
            --verbose
        else
          echo "⚠️ osde2e command not found, running basic validation tests..."

          # Fallback to basic kubectl-based tests if osde2e is not available
          echo "🔍 Running basic operator validation..."

          # Test 1: Operator deployment readiness
          kubectl wait --for=condition=available deployment/{{inputs.parameters.app-name}} \
            -n "${OPERATOR_NAMESPACE}" --timeout=300s
          echo "✅ Operator deployment is ready"

          # Test 2: CRD availability
          kubectl get crd examples.managed.openshift.io
          echo "✅ CRDs are available"

          # Test 3: Create test Example resource
          cat <<EOF | kubectl apply -f -
        apiVersion: managed.openshift.io/v1alpha1
        kind: Example
        metadata:
          name: osde2e-test-example
          namespace: ${OPERATOR_NAMESPACE}
        spec:
          message: "OSDE2E test validation"
        EOF

          # Wait and verify the resource
          sleep 15
          kubectl get example osde2e-test-example -n "${OPERATOR_NAMESPACE}"
          echo "✅ Example resource created and validated"

          # Cleanup
          kubectl delete example osde2e-test-example -n "${OPERATOR_NAMESPACE}" || true
        fi

        echo "🎉 OSDE2E tests completed successfully for {{inputs.parameters.environment}}!"
      env:
      - name: KUBECONFIG
        value: /tmp/kubeconfig/kubeconfig
      - name: OPERATOR_IMAGE
        value: "{{inputs.parameters.image-url}}"
      - name: TEST_ENVIRONMENT
        value: "{{inputs.parameters.environment}}"
      resources:
        limits:
          cpu: 1000m
          memory: 1Gi
        requests:
          cpu: 500m
          memory: 512Mi
      volumeMounts:
      - name: kubeconfig
        mountPath: /tmp/kubeconfig
        readOnly: true
      - name: osde2e-config
        mountPath: /tmp/osde2e-config
        readOnly: true
      securityContext:
        runAsNonRoot: true
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: false
        capabilities:
          drop:
          - ALL

    volumes:
    - name: kubeconfig
      secret:
        secretName: kubeconfig-{{inputs.parameters.environment}}
        defaultMode: 0400
    - name: osde2e-config
      configMap:
        name: osde2e-{{inputs.parameters.environment}}-config

  # Manual approval gate
  - name: manual-approval
    inputs:
      parameters:
      - name: approval-message
      - name: approver
    suspend: {}

  # Post-deployment validation
  - name: validate-deployment
    inputs:
      parameters:
      - name: environment
      - name: app-name
    script:
      image: quay.io/openshift/origin-cli:latest
      command: [bash]
      env:
      - name: KUBECONFIG
        value: /tmp/kubeconfig/kubeconfig
      resources:
        limits:
          cpu: 200m
          memory: 256Mi
        requests:
          cpu: 50m
          memory: 128Mi
      volumeMounts:
      - name: kubeconfig
        mountPath: /tmp/kubeconfig
        readOnly: true
      securityContext:
        runAsNonRoot: true
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: false
        capabilities:
          drop:
          - ALL
      source: |
        set -euo pipefail
        echo "=== Post-deployment validation in {{inputs.parameters.environment}} ==="

        NAMESPACE="{{inputs.parameters.app-name}}-{{inputs.parameters.environment}}"

        # Verify kubeconfig is mounted
        if [ ! -f "${KUBECONFIG}" ]; then
          echo "❌ Kubeconfig not found at ${KUBECONFIG}"
          exit 1
        fi

        # Validate deployment health
        if ! oc get deployment {{inputs.parameters.app-name}} -n "${NAMESPACE}" &>/dev/null; then
          echo "❌ Deployment not found"
          exit 1
        fi

        READY_REPLICAS=$(oc get deployment {{inputs.parameters.app-name}} -n "${NAMESPACE}" -o jsonpath='{.status.readyReplicas}')
        DESIRED_REPLICAS=$(oc get deployment {{inputs.parameters.app-name}} -n "${NAMESPACE}" -o jsonpath='{.spec.replicas}')

        if [ "$READY_REPLICAS" != "$DESIRED_REPLICAS" ]; then
          echo "❌ Post-deployment validation failed: $READY_REPLICAS/$DESIRED_REPLICAS ready"
          exit 1
        fi

        echo "✅ Post-deployment validation passed!"
        echo "📊 Final deployment status:"
        oc get pods -n "${NAMESPACE}" -l app={{inputs.parameters.app-name}}

    volumes:
    - name: kubeconfig
      secret:
        secretName: kubeconfig-{{inputs.parameters.environment}}
        defaultMode: 0400

  # Notification template
  - name: send-notification
    inputs:
      parameters:
      - name: message
      - name: status
      - name: color
        value: "good"
    script:
      image: curlimages/curl:latest
      command: [sh]
      resources:
        limits:
          cpu: 100m
          memory: 64Mi
        requests:
          cpu: 10m
          memory: 32Mi
      securityContext:
        runAsNonRoot: true
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
        capabilities:
          drop:
          - ALL
      source: |
        set -euo pipefail
        echo "📢 Sending notification: {{inputs.parameters.message}}"

        # Send Slack notification if webhook is configured
        if [ -n "{{workflow.parameters.slack-webhook}}" ]; then
          echo "Sending Slack notification..."
          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "text": "{{inputs.parameters.message}}",
              "attachments": [{
                "color": "{{inputs.parameters.color}}",
                "fields": [
                  {"title": "Workflow", "value": "{{workflow.name}}", "short": true},
                  {"title": "Status", "value": "{{inputs.parameters.status}}", "short": true},
                  {"title": "App", "value": "{{workflow.parameters.app-name}}", "short": true},
                  {"title": "Version", "value": "{{workflow.parameters.app-version}}", "short": true}
                ]
              }]
            }' \
            "{{workflow.parameters.slack-webhook}}" || echo "Failed to send Slack notification"
        fi

        # Send generic webhook notification if configured
        if [ -n "{{workflow.parameters.notification-webhook}}" ]; then
          echo "Sending generic webhook notification..."
          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "message": "{{inputs.parameters.message}}",
              "status": "{{inputs.parameters.status}}",
              "workflow": "{{workflow.name}}",
              "app_name": "{{workflow.parameters.app-name}}",
              "app_version": "{{workflow.parameters.app-version}}"
            }' \
            "{{workflow.parameters.notification-webhook}}" || echo "Failed to send webhook notification"
        fi

        echo "✅ Notification processing completed"

  # Exit handler for failure notifications
  - name: notify-on-exit
    steps:
    - - name: send-failure-notification
        template: send-notification
        arguments:
          parameters:
          - name: message
            value: "❌ Deployment pipeline {{workflow.status}} for {{workflow.parameters.app-name}} v{{workflow.parameters.app-version}}"
          - name: status
            value: "{{workflow.status}}"
          - name: color
            value: "danger"
        when: "{{workflow.status}} != 'Succeeded' && {{workflow.parameters.enable-notifications}} == 'true'"